<label>
  <span>
    Starting pressure
    <span class="value">{startPressure}</span>
  </span>
</label>
<div style="width: 100px;">
  <d-slider 
    type="range" min=0 max=2 step=1 ticks value=0
    on:input="updateStartPressure(this.value)">
  </d-slider>
</div>
<label>
    <span>
      End pressure
      <span class="value">{endPressure}</span>
    </span>
  </label>
  <div style="width: 100px;">
    <d-slider 
      type="range" min=0 max=2 step=1 ticks value=0
      on:input="updateEndPressure(this.value)">
    </d-slider>
  </div>
<div class="canvas-container grid">
  <img ref:image hidden src={img_src} alt="">
  <canvas on:click="handleClick(event)" class="stroke-canvas" ref:canvas id="stroke" width="256" height="256"></canvas>
</div>
  
  
  <style>
.canvas-container {
  height: 100%;
  display: flex;
  justify-content: center;
}

.stroke-canvas {
  border: 1px solid black;
}
  </style>
  
  
  <script>
  const SCALE = 4;
  const SELECT_RADIUS = 5;
  const START_X = 8;
  const START_Y = 8;
  const START_COLOR = 'black';
  const END_COLOR = 'green';
  const CONTROL_COLOR = 'orange';
  const END_LIST = [
    [56, 56],
    [56, 8],
    [8, 56]
  ]
  const CONTROL_LIST = [
    [32, 8],
    [56, 32],
    [32, 56]
  ]

  function check_distance_within_limit(pointA, pointB, limit) {
    return limit > Math.sqrt((pointA[0]-pointB[0])**2 + (pointA[1]-pointB[1])**2);
  }

  export default {

    oncreate() {
      const canvas = this.refs.canvas;
      this.ctx = canvas.getContext('2d');

      this.refs.image.onload = () => {
        this.drawCanvas();
      }
    },

    onupdate({ changed, current, previous }) {
			// this fires after oncreate, and after every state change
			// once the DOM is synchronised with the data
      console.log(`The DOM has been updated`, changed, current, previous);
      this.drawCanvas();
		},
    
    methods: {
      handleClick(evt) {
        const rect = this.refs.canvas.getBoundingClientRect();
        const x = (event.clientX - rect.left) / SCALE;
        const y = (event.clientY - rect.top) / SCALE;
        console.log("x: " + x + " y: " + y);
        for (let i = 0; i < 3; i++) {
          if (check_distance_within_limit([x, y], END_LIST[i], SELECT_RADIUS)) {
            this.set({endPoint: END_LIST[i]});
            return;
          }
          if (check_distance_within_limit([x, y], CONTROL_LIST[i], SELECT_RADIUS)) {
            this.set({controlPoint: CONTROL_LIST[i]});
            return;
          }
        }
      },

      drawSelectors() {
        const ctx = this.ctx;

        ctx.lineWidth = 2;
        ctx.setLineDash([4, 2]);

        ctx.fillStyle = START_COLOR;
        ctx.beginPath();
        ctx.arc(SCALE*START_X, SCALE*START_Y, SELECT_RADIUS, 0, Math.PI * 2, true);
        ctx.fill();

        ctx.lineWidth = 2;
        ctx.setLineDash([4, 2]);

        ctx.strokeStyle = CONTROL_COLOR;
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          ctx.arc(SCALE*CONTROL_LIST[i][0], SCALE*CONTROL_LIST[i][1], SELECT_RADIUS, 0, Math.PI * 2, true);
          ctx.stroke();
        }

        ctx.strokeStyle = END_COLOR;
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          ctx.arc(SCALE*END_LIST[i][0], SCALE*END_LIST[i][1], SELECT_RADIUS, 0, Math.PI * 2, true);
          ctx.stroke();
        }
      },

      drawShadedSelectors() {
        const { endPoint, controlPoint } = this.get();
        const ctx = this.ctx;

        ctx.fillStyle = CONTROL_COLOR;
        ctx.beginPath();
        ctx.arc(SCALE*controlPoint[0], SCALE*controlPoint[1], SELECT_RADIUS, 0, Math.PI * 2, true);
        ctx.fill();

        ctx.fillStyle = END_COLOR;
        ctx.beginPath();
        ctx.arc(SCALE*endPoint[0], SCALE*endPoint[1], SELECT_RADIUS, 0, Math.PI * 2, true);
        ctx.fill();
      },

      drawCanvas() {
        this.clearCanvas();
        this.ctx.drawImage(this.refs.image, 0, 0);
        this.drawSelectors();
        this.drawShadedSelectors();
      },

      clearCanvas() {
        this.ctx.clearRect(0, 0, 256, 256); // clear canvas
      },

      updateStartPressure(val) {
        console.log("starting pressure", val);
        if (this.ctx !== undefined) {  // What the fuck? Make sure oncreate is called before doing any set() calls.
          this.set({startPressure: val});
        };
      },

      updateEndPressure(val) {
        console.log("end pressure", val);
        if (this.ctx !== undefined) {  // What the fuck? Make sure oncreate is called before doing any set() calls.
          this.set({endPressure: val});
        };
      }
    },
    
    data() {
      return {
        endPoint: END_LIST[0],
        controlPoint: CONTROL_LIST[0],
        startPressure: 0,
        endPressure: 0,
      }
    },

    computed: {
      img_src: ({endPoint}) => {
        if (endPoint === END_LIST[0]) {
          return "images/mypaint-vis/a.png";
        } else {
          return "images/mypaint-vis/download.png";
        }
      },
      // sprite_url: ({sprite_urls, sprite_url_index}) => sprite_urls[sprite_url_index],
      // sprite_width: ({sprite_url_index}) => sprite_url_index == 0 ? 100 : 300,
    },
  }
  </script>
  